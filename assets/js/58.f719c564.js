(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{498:function(s,a,t){"use strict";t.r(a);var e=t(76),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"命名管道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命名管道"}},[s._v("#")]),s._v(" 命名管道")]),s._v(" "),t("p",[s._v("在大多数类似 Unix 的操作系统中，有可能创建一种特殊类型的文件，叫做命名管道。命名管道用来在 两个进程之间建立连接，也可以像其它类型的文件一样使用。")]),s._v(" "),t("p",[s._v("命令管道的行为类似于文件，但实际上形成了先入先出（FIFO）的缓冲。和普通（未命令的）管道一样， 数据从一端进入，然后从另一端出现。通过命令管道，有可能像这样设置一些东西：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("process1 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" named_pipe\n")])])]),t("p",[s._v("和")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("process2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" named_pipe\n")])])]),t("p",[s._v("表现出来就像这样：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("process1 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" process2\n")])])]),t("h2",{attrs:{id:"设置一个命名管道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置一个命名管道"}},[s._v("#")]),s._v(" 设置一个命名管道")]),s._v(" "),t("p",[s._v("使用 mkfifo 命令能够创建命令管道：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("$ "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("mkfifo")]),s._v(" pipe1\n$ "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("ls")]),s._v(" -l pipe1\nprw-r--r-- "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" me me "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2009")]),s._v("-07-17 06:41 pipe1\n")])])]),t("p",[s._v("这里我们使用 mkfifo 创建了一个名为 pipe1 的命名管道。使用 ls 命令，我们查看这个文件， 看到位于属性字段的第一个字母是 “p”，表明它是一个命名管道。")]),s._v(" "),t("h2",{attrs:{id:"使用命名管道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用命名管道"}},[s._v("#")]),s._v(" 使用命名管道")]),s._v(" "),t("p",[s._v("为了演示命名管道是如何工作的，我们将需要两个终端窗口（或用两个虚拟控制台代替）。 在第一个终端中，我们输入一个简单命令，并把命令的输出重定向到命名管道：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("$ "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("ls")]),s._v(" -l "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" pipe1\n")])])]),t("p",[s._v("我们按下 Enter 按键之后，命令将会挂起。这是因为在管道的另一端没有任何接受数据。当这种现象发生的时候， 据说是管道阻塞了。一旦我们绑定一个进程到管道的另一端，该进程开始从管道中读取输入的时候，这种情况会消失。 使用第二个终端窗口，我们输入这个命令。")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("$ "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("cat")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" pipe1\n")])])]),t("p",[s._v("然后产自第一个终端窗口的目录列表出现在第二个终端中，并作为来自 cat 命令的输出。在第一个终端 窗口中的 ls 命令一旦它不再阻塞，会成功地结束。")])])}),[],!1,null,null,null);a.default=r.exports}}]);